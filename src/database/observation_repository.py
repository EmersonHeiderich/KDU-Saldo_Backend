# src/database/observation_repository.py
# Handles database operations specifically for Product Observations.

import sqlite3
from datetime import datetime
from typing import List, Optional, Dict, Any
from .base_repository import BaseRepository
from .connection_pool import ConnectionPool # Required for type hint
from src.domain.observation import Observation # Import the domain model
from src.utils.logger import logger
from src.api.errors import DatabaseError, NotFoundError

class ObservationRepository(BaseRepository):
    """
    Repository for managing Product Observations in the database.
    """

    def __init__(self, connection_pool: ConnectionPool):
        super().__init__(connection_pool)
        logger.info("ObservationRepository initialized.")

    def add(self, observation: Observation) -> Observation:
        """
        Adds a new observation to the database.

        Args:
            observation: An Observation object (without an ID).

        Returns:
            The Observation object with the generated ID and timestamp.

        Raises:
            DatabaseError: If the insertion fails.
            ValueError: If required observation fields are missing.
        """
        if not observation.reference_code or not observation.observation_text or not observation.user:
             raise ValueError("Missing required fields (reference_code, observation_text, user) for Observation.")

        query = """
            INSERT INTO product_observations
            (reference_code, observation, user, timestamp, resolved, resolved_user, resolved_timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """
        # Use current time if timestamp not set, ensure resolved defaults are correct
        now = datetime.now()
        params = (
            observation.reference_code,
            observation.observation_text,
            observation.user,
            observation.timestamp or now,
            observation.resolved, # Should be False for new
            observation.resolved_user,
            observation.resolved_timestamp
        )
        try:
            last_id = self._execute(query, params, fetch_mode="none")
            if last_id is None:
                raise DatabaseError("Failed to insert observation, no ID returned.")

            observation.id = last_id
            # Update timestamp if it was generated by the DB (e.g., CURRENT_TIMESTAMP default)
            # This requires another query or trusting the initial 'now' time.
            # For simplicity, we trust 'now' or the passed timestamp.
            if observation.timestamp is None:
                 observation.timestamp = now

            logger.info(f"Observation added successfully with ID: {observation.id} for ref: {observation.reference_code}")
            return observation
        except sqlite3.IntegrityError as e:
             logger.error(f"Database integrity error adding observation: {e}", exc_info=True)
             raise DatabaseError(f"Failed to add observation due to integrity constraint: {e}") from e
        # BaseRepository._execute already wraps other sqlite3.Error and general exceptions

    def find_by_id(self, observation_id: int) -> Optional[Observation]:
        """
        Finds an observation by its ID.

        Args:
            observation_id: The ID of the observation.

        Returns:
            An Observation object if found, otherwise None.

        Raises:
            DatabaseError: For database errors during lookup.
        """
        query = "SELECT * FROM product_observations WHERE id = ?"
        try:
            row = self._execute(query, (observation_id,), fetch_mode="one")
            if row:
                 return Observation.from_dict(row)
            return None
        except Exception as e:
             logger.error(f"Error finding observation by ID {observation_id}: {e}", exc_info=True)
             # Don't raise DatabaseError here, service layer should handle None return
             return None


    def find_by_reference_code(self, reference_code: str, include_resolved: bool = True) -> List[Observation]:
        """
        Finds all observations for a given product reference code.

        Args:
            reference_code: The product reference code.
            include_resolved: Whether to include resolved observations.

        Returns:
            A list of Observation objects, ordered by timestamp descending.

        Raises:
            DatabaseError: For database errors during lookup.
        """
        if include_resolved:
             query = "SELECT * FROM product_observations WHERE reference_code = ? ORDER BY timestamp DESC"
             params = (reference_code,)
        else:
             query = "SELECT * FROM product_observations WHERE reference_code = ? AND resolved = 0 ORDER BY timestamp DESC"
             params = (reference_code,)

        try:
            rows = self._execute(query, params, fetch_mode="all")
            observations = [Observation.from_dict(row) for row in rows if row]
            # Filter out None results from potential parsing errors
            observations = [obs for obs in observations if obs is not None]
            logger.debug(f"Found {len(observations)} observations for reference code '{reference_code}' (include_resolved={include_resolved}).")
            return observations
        except Exception as e:
             logger.error(f"Error finding observations by reference code {reference_code}: {e}", exc_info=True)
             return [] # Return empty list on error


    def update(self, observation: Observation) -> bool:
        """
        Updates an existing observation in the database.

        Args:
            observation: The Observation object with updated data (must have an ID).

        Returns:
            True if the update was successful (at least one row affected), False otherwise.

        Raises:
            DatabaseError: If the update fails.
            ValueError: If the observation object does not have an ID.
        """
        if observation.id is None:
            raise ValueError("Cannot update observation without an ID.")

        query = """
            UPDATE product_observations SET
                reference_code = ?,
                observation = ?,
                user = ?,
                timestamp = ?,
                resolved = ?,
                resolved_user = ?,
                resolved_timestamp = ?
            WHERE id = ?
        """
        params = (
            observation.reference_code,
            observation.observation_text,
            observation.user,
            observation.timestamp,
            observation.resolved,
            observation.resolved_user,
            observation.resolved_timestamp,
            observation.id
        )

        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            cursor.execute(query, params)
            rows_affected = cursor.rowcount
            conn.commit()
            logger.info(f"Observation ID {observation.id} update attempted. Rows affected: {rows_affected}")
            return rows_affected > 0
        except sqlite3.Error as e:
            if conn: conn.rollback()
            logger.error(f"Database error updating observation ID {observation.id}: {e}", exc_info=True)
            raise DatabaseError(f"Failed to update observation: {e}") from e
        except Exception as e:
             if conn: conn.rollback()
             logger.error(f"Unexpected error updating observation ID {observation.id}: {e}", exc_info=True)
             raise DatabaseError(f"An unexpected error occurred while updating observation: {e}") from e
        finally:
            if conn:
                self._release_connection(conn)

    def mark_as_resolved(self, observation_id: int, resolved_by_user: str) -> bool:
        """
        Marks a specific observation as resolved.

        Args:
            observation_id: The ID of the observation to resolve.
            resolved_by_user: The username of the user resolving the observation.

        Returns:
            True if the update was successful (one row affected), False otherwise.

        Raises:
            DatabaseError: If the update fails.
        """
        query = """
            UPDATE product_observations SET
                resolved = 1,
                resolved_user = ?,
                resolved_timestamp = ?
            WHERE id = ? AND resolved = 0
        """
        now = datetime.now()
        params = (resolved_by_user, now, observation_id)

        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            cursor.execute(query, params)
            rows_affected = cursor.rowcount
            conn.commit()
            if rows_affected > 0:
                 logger.info(f"Observation ID {observation_id} marked as resolved by {resolved_by_user}.")
                 return True
            else:
                 # Check if it didn't update because it was already resolved or didn't exist
                 existing = self.find_by_id(observation_id)
                 if existing and existing.resolved:
                      logger.warning(f"Observation ID {observation_id} was already resolved.")
                      # Consider returning True if already resolved? Or False as no change was made?
                      # Returning False indicates no *change* was made by this call.
                      return False
                 elif not existing:
                      logger.warning(f"Attempted to resolve non-existent observation ID {observation_id}.")
                      raise NotFoundError(f"Observation with ID {observation_id} not found.")
                 else:
                      # Should not happen if query includes resolved = 0
                      logger.error(f"Failed to mark observation ID {observation_id} as resolved, but it exists and is not resolved. Unknown state.")
                      return False

        except sqlite3.Error as e:
            if conn: conn.rollback()
            logger.error(f"Database error marking observation ID {observation_id} as resolved: {e}", exc_info=True)
            raise DatabaseError(f"Failed to resolve observation: {e}") from e
        except NotFoundError:
             raise # Re-raise NotFoundError
        except Exception as e:
             if conn: conn.rollback()
             logger.error(f"Unexpected error marking observation ID {observation_id} as resolved: {e}", exc_info=True)
             raise DatabaseError(f"An unexpected error occurred while resolving observation: {e}") from e
        finally:
            if conn:
                self._release_connection(conn)


    def get_unresolved_count(self, reference_code: str) -> int:
        """
        Gets the count of unresolved observations for a reference code.

        Args:
            reference_code: The product reference code.

        Returns:
            The number of unresolved observations.

        Raises:
            DatabaseError: For database errors during count.
        """
        query = "SELECT COUNT(*) FROM product_observations WHERE reference_code = ? AND resolved = 0"
        try:
            result = self._execute(query, (reference_code,), fetch_mode="one")
            count = result['COUNT(*)'] if result else 0
            logger.debug(f"Unresolved observation count for ref '{reference_code}': {count}")
            return count
        except Exception as e:
            # Let _execute handle logging, just return 0 or raise
            logger.error(f"Failed to get unresolved observation count for ref '{reference_code}': {e}", exc_info=True)
            # Depending on requirements, either return 0 or re-raise a DatabaseError
            return 0 # Return 0 on error

    def get_references_with_pending(self) -> List[Dict[str, Any]]:
        """
        Gets distinct reference codes that have at least one unresolved observation,
        along with details of the most recent pending observation for each reference.

        Returns:
            A list of dictionaries, each containing 'reference_code', 'user', and 'timestamp'
            of the latest unresolved observation for that reference code.
        """
        # This query uses a common table expression (CTE) and window functions if SQLite version supports it,
        # otherwise a subquery can be used. Let's use a subquery for broader compatibility.
        query = """
            SELECT
                po.reference_code,
                po.user,
                po.timestamp
            FROM product_observations po
            WHERE po.resolved = 0
              AND po.timestamp = (
                  SELECT MAX(sub.timestamp)
                  FROM product_observations sub
                  WHERE sub.reference_code = po.reference_code
                    AND sub.resolved = 0
              )
            ORDER BY po.timestamp DESC;
        """
        # Alternative using GROUP BY (might be slightly less accurate if multiple users post at exact same ms)
        # query = """
        #     SELECT reference_code, user, MAX(timestamp) as timestamp
        #     FROM product_observations
        #     WHERE resolved = 0
        #     GROUP BY reference_code
        #     ORDER BY timestamp DESC
        # """
        try:
            results = self._execute(query, fetch_mode="all")
            # Ensure timestamp is formatted if needed for JSON
            for r in results:
                 if isinstance(r.get('timestamp'), datetime):
                      r['timestamp'] = r['timestamp'].isoformat()
            logger.debug(f"Found {len(results)} references with pending observations.")
            return results
        except Exception as e:
            logger.error(f"Failed to get references with pending observations: {e}", exc_info=True)
            return [] # Return empty list on error

    def delete_by_id(self, observation_id: int) -> bool:
        """
        Deletes an observation by its ID.

        Args:
            observation_id: The ID of the observation to delete.

        Returns:
            True if deletion was successful (one row affected), False otherwise.

        Raises:
            DatabaseError: If the deletion fails.
        """
        query = "DELETE FROM product_observations WHERE id = ?"
        conn = None
        try:
            conn = self._get_connection()
            cursor = conn.cursor()
            cursor.execute(query, (observation_id,))
            rows_affected = cursor.rowcount
            conn.commit()
            logger.info(f"Observation ID {observation_id} deletion attempted. Rows affected: {rows_affected}")
            return rows_affected > 0
        except sqlite3.Error as e:
             if conn: conn.rollback()
             logger.error(f"Database error deleting observation ID {observation_id}: {e}", exc_info=True)
             raise DatabaseError(f"Failed to delete observation: {e}") from e
        except Exception as e:
             if conn: conn.rollback()
             logger.error(f"Unexpected error deleting observation ID {observation_id}: {e}", exc_info=True)
             raise DatabaseError(f"An unexpected error occurred while deleting observation: {e}") from e
        finally:
             if conn:
                  self._release_connection(conn)